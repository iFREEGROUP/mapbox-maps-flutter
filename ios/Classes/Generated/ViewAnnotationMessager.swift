// Autogenerated from Pigeon (v17.0.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation

#if os(iOS)
  import Flutter
#elseif os(macOS)
  import FlutterMacOS
#else
  #error("Unsupported platform.")
#endif

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details,
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)",
  ]
}

private func createConnectionError(withChannelName channelName: String) -> FlutterError {
  return FlutterError(code: "channel-error", message: "Unable to establish connection on channel: '\(channelName)'.", details: "")
}

private func isNullish(_ value: Any?) -> Bool {
  return value is NSNull || value == nil
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

enum AnnotatedFeatureType: Int {
  case gEOMETRY = 0
  case aNNOTATEDLAYERFEATURE = 1
}

enum FLTViewAnnotationAnchor: Int {
  case cENTER = 0
  case tOP = 1
  case lEFT = 2
  case bOTTOM = 3
  case rIGHT = 4
  case tOPLEFT = 5
  case bOTTOMRIGHT = 6
  case tOPRIGHT = 7
  case bOTTOMLEFT = 8
}

enum ViewAnnotationUpdateMode: Int {
  case mAPFIXEDDELAY = 0
  case mAPSYNCHRONIZED = 1
}

/// Generated class from Pigeon that represents data sent in messages.
struct AnnotatedFeature {
  var value: Any
  var type: AnnotatedFeatureType

  static func fromList(_ list: [Any?]) -> AnnotatedFeature? {
    let value = list[0]!
    let type = AnnotatedFeatureType(rawValue: list[1] as! Int)!

    return AnnotatedFeature(
      value: value,
      type: type
    )
  }
  func toList() -> [Any?] {
    return [
      value,
      type.rawValue,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct ViewAnnotationAnchorConfig {
  var anchor: FLTViewAnnotationAnchor
  var offsetX: Double
  var offsetY: Double

  static func fromList(_ list: [Any?]) -> ViewAnnotationAnchorConfig? {
    let anchor = FLTViewAnnotationAnchor(rawValue: list[0] as! Int)!
    let offsetX = list[1] as! Double
    let offsetY = list[2] as! Double

    return ViewAnnotationAnchorConfig(
      anchor: anchor,
      offsetX: offsetX,
      offsetY: offsetY
    )
  }
  func toList() -> [Any?] {
    return [
      anchor.rawValue,
      offsetX,
      offsetY,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct ViewAnnotationOptions {
  var annotatedFeature: AnnotatedFeature? = nil
  var width: Double? = nil
  var height: Double? = nil
  var allowOverlap: Bool? = nil
  var allowOverlapWithPuck: Bool? = nil
  var visible: Bool? = nil
  var variableAnchors: [ViewAnnotationAnchorConfig?]? = nil
  var selected: Bool? = nil
  var ignoreCameraPadding: Bool? = nil

  static func fromList(_ list: [Any?]) -> ViewAnnotationOptions? {
    var annotatedFeature: AnnotatedFeature? = nil
    if let annotatedFeatureList: [Any?] = nilOrValue(list[0]) {
      annotatedFeature = AnnotatedFeature.fromList(annotatedFeatureList)
    }
    let width: Double? = nilOrValue(list[1])
    let height: Double? = nilOrValue(list[2])
    let allowOverlap: Bool? = nilOrValue(list[3])
    let allowOverlapWithPuck: Bool? = nilOrValue(list[4])
    let visible: Bool? = nilOrValue(list[5])
    let variableAnchors: [ViewAnnotationAnchorConfig?]? = nilOrValue(list[6])
    let selected: Bool? = nilOrValue(list[7])
    let ignoreCameraPadding: Bool? = nilOrValue(list[8])

    return ViewAnnotationOptions(
      annotatedFeature: annotatedFeature,
      width: width,
      height: height,
      allowOverlap: allowOverlap,
      allowOverlapWithPuck: allowOverlapWithPuck,
      visible: visible,
      variableAnchors: variableAnchors,
      selected: selected,
      ignoreCameraPadding: ignoreCameraPadding
    )
  }
  func toList() -> [Any?] {
    return [
      annotatedFeature?.toList(),
      width,
      height,
      allowOverlap,
      allowOverlapWithPuck,
      visible,
      variableAnchors,
      selected,
      ignoreCameraPadding,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct AnnotatedLayerFeature {
  var layerId: String
  var featureId: String? = nil

  static func fromList(_ list: [Any?]) -> AnnotatedLayerFeature? {
    let layerId = list[0] as! String
    let featureId: String? = nilOrValue(list[1])

    return AnnotatedLayerFeature(
      layerId: layerId,
      featureId: featureId
    )
  }
  func toList() -> [Any?] {
    return [
      layerId,
      featureId,
    ]
  }
}

private class ViewAnnotationManagerCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 128:
      return AnnotatedFeature.fromList(self.readValue() as! [Any?])
    case 129:
      return AnnotatedLayerFeature.fromList(self.readValue() as! [Any?])
    case 130:
      return ViewAnnotationAnchorConfig.fromList(self.readValue() as! [Any?])
    case 131:
      return ViewAnnotationOptions.fromList(self.readValue() as! [Any?])
    case 132:
      return ViewAnnotationOptions.fromList(self.readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class ViewAnnotationManagerCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? AnnotatedFeature {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else if let value = value as? AnnotatedLayerFeature {
      super.writeByte(129)
      super.writeValue(value.toList())
    } else if let value = value as? ViewAnnotationAnchorConfig {
      super.writeByte(130)
      super.writeValue(value.toList())
    } else if let value = value as? ViewAnnotationOptions {
      super.writeByte(131)
      super.writeValue(value.toList())
    } else if let value = value as? ViewAnnotationOptions {
      super.writeByte(132)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class ViewAnnotationManagerCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return ViewAnnotationManagerCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return ViewAnnotationManagerCodecWriter(data: data)
  }
}

class ViewAnnotationManagerCodec: FlutterStandardMessageCodec {
  static let shared = ViewAnnotationManagerCodec(readerWriter: ViewAnnotationManagerCodecReaderWriter())
}

/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol ViewAnnotationManager {
  func addViewAnnotation(data: FlutterStandardTypedData, options: ViewAnnotationOptions, completion: @escaping (Result<Int64, Error>) -> Void)
  func removeAllViewAnnotations(completion: @escaping (Result<Void, Error>) -> Void)
  func removeViewAnnotation(viewId: Int64, completion: @escaping (Result<Void, Error>) -> Void)
  func updateViewAnnotation(viewId: Int64, options: ViewAnnotationOptions, data: FlutterStandardTypedData?, completion: @escaping (Result<Bool, Error>) -> Void)
  func getViewAnnotationOptions(annotatedLayerFeature: AnnotatedLayerFeature, completion: @escaping (Result<ViewAnnotationOptions?, Error>) -> Void)
  func getViewAnnotationOptionsByViewId(viewId: Int64, completion: @escaping (Result<ViewAnnotationOptions?, Error>) -> Void)
  func setViewAnnotationUpdateMode(mode: ViewAnnotationUpdateMode, completion: @escaping (Result<Void, Error>) -> Void)
  func getViewAnnotationUpdateMode(completion: @escaping (Result<ViewAnnotationUpdateMode, Error>) -> Void)
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class ViewAnnotationManagerSetup {
  /// The codec used by ViewAnnotationManager.
  static var codec: FlutterStandardMessageCodec { ViewAnnotationManagerCodec.shared }
  /// Sets up an instance of `ViewAnnotationManager` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: ViewAnnotationManager?) {
    let addViewAnnotationChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.ViewAnnotationManager.addViewAnnotation", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      addViewAnnotationChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let dataArg = args[0] as! FlutterStandardTypedData
        let optionsArg = args[1] as! ViewAnnotationOptions
        api.addViewAnnotation(data: dataArg, options: optionsArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      addViewAnnotationChannel.setMessageHandler(nil)
    }
    let removeAllViewAnnotationsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.ViewAnnotationManager.removeAllViewAnnotations", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      removeAllViewAnnotationsChannel.setMessageHandler { _, reply in
        api.removeAllViewAnnotations { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      removeAllViewAnnotationsChannel.setMessageHandler(nil)
    }
    let removeViewAnnotationChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.ViewAnnotationManager.removeViewAnnotation", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      removeViewAnnotationChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        api.removeViewAnnotation(viewId: viewIdArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      removeViewAnnotationChannel.setMessageHandler(nil)
    }
    let updateViewAnnotationChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.ViewAnnotationManager.updateViewAnnotation", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      updateViewAnnotationChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let optionsArg = args[1] as! ViewAnnotationOptions
        let dataArg: FlutterStandardTypedData? = nilOrValue(args[2])
        api.updateViewAnnotation(viewId: viewIdArg, options: optionsArg, data: dataArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      updateViewAnnotationChannel.setMessageHandler(nil)
    }
    let getViewAnnotationOptionsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.ViewAnnotationManager.getViewAnnotationOptions", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getViewAnnotationOptionsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let annotatedLayerFeatureArg = args[0] as! AnnotatedLayerFeature
        api.getViewAnnotationOptions(annotatedLayerFeature: annotatedLayerFeatureArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getViewAnnotationOptionsChannel.setMessageHandler(nil)
    }
    let getViewAnnotationOptionsByViewIdChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.ViewAnnotationManager.getViewAnnotationOptionsByViewId", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getViewAnnotationOptionsByViewIdChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let viewIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        api.getViewAnnotationOptionsByViewId(viewId: viewIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getViewAnnotationOptionsByViewIdChannel.setMessageHandler(nil)
    }
    let setViewAnnotationUpdateModeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.ViewAnnotationManager.setViewAnnotationUpdateMode", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setViewAnnotationUpdateModeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let modeArg = ViewAnnotationUpdateMode(rawValue: args[0] as! Int)!
        api.setViewAnnotationUpdateMode(mode: modeArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setViewAnnotationUpdateModeChannel.setMessageHandler(nil)
    }
    let getViewAnnotationUpdateModeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.ViewAnnotationManager.getViewAnnotationUpdateMode", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getViewAnnotationUpdateModeChannel.setMessageHandler { _, reply in
        api.getViewAnnotationUpdateMode { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res.rawValue))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getViewAnnotationUpdateModeChannel.setMessageHandler(nil)
    }
  }
}
private class OnViewAnnotationUpdatedListenerCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 128:
      return AnnotatedFeature.fromList(self.readValue() as! [Any?])
    case 129:
      return AnnotatedLayerFeature.fromList(self.readValue() as! [Any?])
    case 130:
      return ScreenCoordinate.fromList(self.readValue() as! [Any?])
    case 131:
      return ViewAnnotationAnchorConfig.fromList(self.readValue() as! [Any?])
    case 132:
      return ViewAnnotationOptions.fromList(self.readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class OnViewAnnotationUpdatedListenerCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? AnnotatedFeature {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else if let value = value as? AnnotatedLayerFeature {
      super.writeByte(129)
      super.writeValue(value.toList())
    } else if let value = value as? ScreenCoordinate {
      super.writeByte(130)
      super.writeValue(value.toList())
    } else if let value = value as? ViewAnnotationAnchorConfig {
      super.writeByte(131)
      super.writeValue(value.toList())
    } else if let value = value as? ViewAnnotationOptions {
      super.writeByte(132)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class OnViewAnnotationUpdatedListenerCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return OnViewAnnotationUpdatedListenerCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return OnViewAnnotationUpdatedListenerCodecWriter(data: data)
  }
}

class OnViewAnnotationUpdatedListenerCodec: FlutterStandardMessageCodec {
  static let shared = OnViewAnnotationUpdatedListenerCodec(readerWriter: OnViewAnnotationUpdatedListenerCodecReaderWriter())
}

/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol OnViewAnnotationUpdatedListenerProtocol {
  func onViewAnnotationPositionUpdated(viewId viewIdArg: Int64, leftTopCoordinate leftTopCoordinateArg: ScreenCoordinate, width widthArg: Double, height heightArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void)
  func onViewAnnotationAnchorCoordinateUpdated(viewId viewIdArg: Int64, anchorCoordinate anchorCoordinateArg: [String?: Any?]?, completion: @escaping (Result<Void, FlutterError>) -> Void)
  func onViewAnnotationAnchorUpdated(viewId viewIdArg: Int64, anchor anchorArg: ViewAnnotationAnchorConfig, completion: @escaping (Result<Void, FlutterError>) -> Void)
  func onViewAnnotationVisibilityUpdated(viewId viewIdArg: Int64, visible visibleArg: Bool, completion: @escaping (Result<Void, FlutterError>) -> Void)
}
class OnViewAnnotationUpdatedListener: OnViewAnnotationUpdatedListenerProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  init(binaryMessenger: FlutterBinaryMessenger) {
    self.binaryMessenger = binaryMessenger
  }
  var codec: FlutterStandardMessageCodec {
    return OnViewAnnotationUpdatedListenerCodec.shared
  }
  func onViewAnnotationPositionUpdated(viewId viewIdArg: Int64, leftTopCoordinate leftTopCoordinateArg: ScreenCoordinate, width widthArg: Double, height heightArg: Double, completion: @escaping (Result<Void, FlutterError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.mapbox_maps_flutter.OnViewAnnotationUpdatedListener.onViewAnnotationPositionUpdated"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([viewIdArg, leftTopCoordinateArg, widthArg, heightArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
  func onViewAnnotationAnchorCoordinateUpdated(viewId viewIdArg: Int64, anchorCoordinate anchorCoordinateArg: [String?: Any?]?, completion: @escaping (Result<Void, FlutterError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.mapbox_maps_flutter.OnViewAnnotationUpdatedListener.onViewAnnotationAnchorCoordinateUpdated"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([viewIdArg, anchorCoordinateArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
  func onViewAnnotationAnchorUpdated(viewId viewIdArg: Int64, anchor anchorArg: ViewAnnotationAnchorConfig, completion: @escaping (Result<Void, FlutterError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.mapbox_maps_flutter.OnViewAnnotationUpdatedListener.onViewAnnotationAnchorUpdated"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([viewIdArg, anchorArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
  func onViewAnnotationVisibilityUpdated(viewId viewIdArg: Int64, visible visibleArg: Bool, completion: @escaping (Result<Void, FlutterError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.mapbox_maps_flutter.OnViewAnnotationUpdatedListener.onViewAnnotationVisibilityUpdated"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([viewIdArg, visibleArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}
/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol OnViewAnnotationTapListenerProtocol {
  func onViewAnnotationClick(viewId viewIdArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void)
}
class OnViewAnnotationTapListener: OnViewAnnotationTapListenerProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  init(binaryMessenger: FlutterBinaryMessenger) {
    self.binaryMessenger = binaryMessenger
  }
  func onViewAnnotationClick(viewId viewIdArg: Int64, completion: @escaping (Result<Void, FlutterError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.mapbox_maps_flutter.OnViewAnnotationTapListener.onViewAnnotationClick"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger)
    channel.sendMessage([viewIdArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}
